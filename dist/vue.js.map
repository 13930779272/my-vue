{"version":3,"file":"vue.js","sources":["../src/compiler/parser.js","../src/compiler/index.js","../src/utils.js","../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["\r\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 匹配标签名的 aa-xxx\r\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; // 命名空间标签 aa:aa-xxx\r\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名 索引第一个 [1]\r\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div> 索引第一个 [1]\r\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的 a=xxx a=\"xxx\" a='xxx'\r\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的  > />\r\n\r\n\r\n// 解析html,会编译成一个对象非常像虚拟DOM但是不是虚拟DOM\r\nfunction parserHTML(html) {\r\n  // 构建一个栈，当解析到一个标签的时候就放进去一个，再有下一个标签就是栈里边最后一个的儿子，当解析到结束标签的时候就从栈里边删掉，自闭和标签同理\r\n  let stack = [];\r\n  // 树根\r\n  let root = null;\r\n\r\n  function createAstElement(tag, attrs, parent = null) {\r\n    return {\r\n      tag,\r\n      type: 1,\r\n      children: [],\r\n      parent,\r\n      attrs\r\n    }\r\n  }\r\n  // 如何构建一棵树，构建父子关系\r\n  function start(tag, attrs) {\r\n    console.log(tag, attrs);\r\n    // 遇到开始标签 就取栈中最后一个作为父节点\r\n    let parent = stack[stack.length - 1];\r\n    let element = createAstElement(tag, attrs, parent);\r\n    // root等于null证明 当前解析的就是根节点\r\n    if(root === null) {\r\n      root = element\r\n    };\r\n    if(parent) {\r\n      // 如果有父级就更新当前的标签的parent 指向 parent\r\n      element.parent = parent;\r\n      // parent 的children 里放上 element\r\n      parent.children.push(element)\r\n    }\r\n    stack.push(element);\r\n\r\n  }\r\n  function end(tagName) {\r\n    console.log(tagName);\r\n    let endTag = stack.pop();\r\n    if(endTag.tag != tagName) {\r\n      console.log('标签出错')\r\n    }\r\n  }\r\n  function text(chars) {\r\n    let parent = stack[stack.length - 1];\r\n    // 替换空格\r\n    chars = chars.replace(/\\s/g, \"\");\r\n    console.log(chars);\r\n    if (chars) {\r\n      parent.children.push({\r\n        type: 2,\r\n        text: chars\r\n      })\r\n    }\r\n  }\r\n  // 删除匹配到（已经解析完成的）的字符\r\n  function advance(len) {\r\n    html = html.substring(len)\r\n  };\r\n  // 处理开始标签\r\n  function parseStartTag() {\r\n    // 匹配开始标签，我们要的是开始标签的名字\r\n    const start = html.match(startTagOpen);\r\n    if(start) {\r\n      const match = {\r\n        // 标签的名字是[1]\r\n        tagName: start[1],\r\n        attrs: [] // 标签的属性\r\n      }\r\n      // debugger;\r\n      // 标签一旦解析完成就得删掉\r\n      advance(start[0].length);\r\n      let end;\r\n      let arr;\r\n      // debugger\r\n      // 有属性并且没有匹配到开始标签的结束（> />）就继续循环直到匹配到开始标签的结束（> />）为止\r\n      while(!(end = html.match(startTagClose)) && (arr = html.match(attribute))) {\r\n        // 在match里面添加属性\r\n        match.attrs.push({\r\n          name: arr[1],\r\n          value: arr[3] || arr[4] || arr[5]\r\n        });\r\n        advance(arr[0].length)\r\n      }\r\n      // 最终会匹配到开始标签的关闭，也需要截取掉\r\n      if(end) {\r\n        advance(end[0].length)\r\n      }\r\n      return match;\r\n      // console.log(match, html)\r\n    } else {\r\n      return false\r\n    }\r\n    \r\n  };\r\n  // 处理模板，不停的截取模板，直到模板全部解析完毕\r\n  while(html) {\r\n    // 解析开始标签<, 当 < 在字符串中的索引为零时证明是开始标签的 < \r\n    let index = html.indexOf('<');\r\n    // debugger\r\n    if(index === 0) {\r\n      // 解析开始标签并且把属性也解析出来\r\n      const startTagMatch = parseStartTag();\r\n      console.log(startTagMatch);\r\n      // 开始标签\r\n      if(startTagMatch) {\r\n        start(startTagMatch.tagName, startTagMatch.attrs)\r\n        continue;\r\n      }\r\n      let endTagMatch;\r\n      // < 也有可能是结束标签\r\n      if(endTagMatch = html.match(endTag)) {\r\n        end(endTagMatch[1]);\r\n        advance(endTagMatch[0].length)\r\n        continue;\r\n      }\r\n      break;\r\n    }\r\n    // 处理文本 当index大于零的时候证明 是文本了\r\n    if(index > 0) {\r\n      // 直接拿到文本\r\n      let chars = html.substring(0, index);\r\n      text(chars);\r\n      advance(chars.length)\r\n    }\r\n\r\n  }\r\n  return root;\r\n};\r\n\r\n\r\nexport default parserHTML\r\n","import parserHTML from \"./parser\";\r\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g  // 匹配{{ xxx }}\r\n// \r\nfunction generate(ast) {\r\n  console.log(ast)\r\n  let children = genChildren(ast);\r\n  let code = `_c('${ast.tag}', ${\r\n    ast.attrs.length ? genProps(ast.attrs) : undefined\r\n  }, ${children ? `${children}` : ''})`;\r\n  return code;\r\n}\r\n// 生成属性\r\nfunction genProps(attrs) {\r\n  console.log();\r\n  let str = [];\r\n  for(let i = 0; i < attrs.length; i++) {\r\n    let attr = attrs[i];\r\n    // 样式单独处理成一个对象\r\n    if(attr.name === 'style') {\r\n      let styles = {}\r\n      attr.value.replace(/([^:;]+):([^;:]+)/g, function() {\r\n        styles[arguments[1]] = arguments[2]\r\n      });\r\n      attr.value = styles;\r\n    }\r\n    str.push(`${attr.name}:${JSON.stringify(attr.value)}`);\r\n  }\r\n  return `{${str.join()}}`\r\n  // console.log()\r\n}\r\nfunction genChildren(ast) {\r\n  let children = ast.children;\r\n  if(children) {\r\n    return children.map(item => gen(item)).join(',')\r\n  }\r\n  // console.log(ast);\r\n  return false\r\n}\r\nfunction gen(el) {\r\n  if(el.type === 1) {\r\n    return generate(el)\r\n  } else {\r\n    let text = el.text;\r\n    if(!defaultTagRE.test(text)) return `_v('${text}')`;\r\n    // 有{{}} 这种情况 要做一个普通值和表达式的拼接\r\n    let tokens = [];\r\n\r\n\r\n\r\n    return `_v(${tokens.join('+')})`\r\n    \r\n  }\r\n}\r\nexport function compilerToFunction(template) {\r\n  // 第一步将模板变成ast语法树\r\n  let ast = parserHTML(template);\r\n  // 第二步代码优化 标记静态节点 不是核心暂时略过，直接下一步\r\n\r\n  // 第三步代码生成，生成rneder函数\r\n  // _c => createElement\r\n  // _v => vnode\r\n  // _s => stringify\r\n  let code = generate(ast)\r\n  console.log(code);\r\n  \r\n}","export function isFunction (data) {\r\n  return typeof data == 'function'\r\n}\r\nexport function isObject(data) {\r\n  return typeof data == 'object' && data !== null;\r\n}\r\nexport let isArray = Array.isArray","\r\nlet oldArrayProperty = Array.prototype // 获取数组的老的方法\r\nexport let arrayMethods = Object.create(oldArrayProperty); // 让arrayMethods可以通过__proto__ 找到Array的prototype\r\n// create(property) {\r\n//   let fn = function() {}\r\n//   fn.property = property;\r\n//   return new fn\r\n// }\r\nlet methods = [\r\n  'push',\r\n  'pop',\r\n  'shift',\r\n  'unshift',\r\n  'splice',\r\n  'sort',\r\n  'reverse'\r\n];\r\n\r\nmethods.forEach(method => {\r\n  // 这个操作会把需要重写的方法重写，并且能找到数组上没有重写的方法，原来的方法有，又把特殊的给重写了\r\n  arrayMethods[method] = function (...args) {\r\n    console.log('数组');\r\n    // 数组新增的属性要看一下是不是对象，如果是对象继续进行劫持,可以新增数组属性的方法有splice push unshift\r\n    // 需要调用数组的原生的逻辑,arr.push\r\n    oldArrayProperty[method].call(this, ...args);\r\n    // 调用的原有的方法，还可以添加自己的逻辑，（函数劫持、切片编程）\r\n    // splice 从第三个参数起就是新增的属性，unshift push 所有的参数都是新增的属性\r\n    // inserted是新增属性的数组，遍历数组看一下是否需要二次观测\r\n    let inserted = [];\r\n    let ob = this.__ob__\r\n    switch(method) {\r\n      case 'splice':\r\n        inserted = args.slice(2);\r\n        break\r\n      case 'push':\r\n        inserted = args;\r\n        break\r\n      case 'unshift':\r\n        inserted = args;\r\n        break\r\n    };\r\n    // inserted[] 遍历数组 看一下它是否需要进行劫持\r\n    if(inserted.length) ob.observeArray(inserted);\r\n  }\r\n})","import { isArray, isObject } from \"../utils\"\r\nimport { arrayMethods } from \"./array\";\r\nclass Observer {\r\n  // 对象可以递归，数组里面的数组也得递归\r\n  constructor(data) {\r\n    // 我给对象和数组添加一个自定义属性，这种情况会有死循环了，对象会一直遍历自己身上的属性，__ob__有__ob__,死循环\r\n    // data.__ob__ = this;\r\n    // 不让__ob__ 被遍历到\r\n    // 这样就不会有死循环了，我们打印vue的数据都会看到__ob__这样一个属性就是这加的\r\n    Object.defineProperty(data, '__ob__', {\r\n      value:this,\r\n      enumerable:false // 标识这个属性不能被列举出来，不能被循环到\r\n    })\r\n    // 判断,根数据必须是一个对象所以第一次一定会走到walk里去\r\n    if(isArray(data)) { // 如果是数组就进去\r\n      // 更改数组的原型方法,\r\n      data.__proto__ = arrayMethods;\r\n      // 假如数组里面有对象或者数组的话，就需要再把数组的每一项递归一遍\r\n      this.observeArray(data)\r\n    } else {\r\n      this.walk(data); // 核心就是循环对象\r\n    }\r\n    \r\n  }\r\n  observeArray (data) { // 递归遍历数组，把数组里面的[{}] [[]] 再次重写\r\n    data.forEach(item => observe(item))\r\n  }\r\n  walk(data) {\r\n    Object.keys(data).forEach(key => { // 使用Object.defineProperty重写数据\r\n      defineReactive(data, key, data[key]);\r\n    })\r\n  }\r\n}\r\n// vue2应用了defineProperty需要一加载时就进行递归操作，所以耗费性能，层次过深更严重\r\n// 1.性能优化的原则\r\n// 1) 不要把所有的数据都放到data中，因为所有的数据都会增加get和set\r\n// 2) 数据不要层次过深，尽量扁平化使用\r\n// 3) 不要频繁的获取数据\r\n// 4) 如果数据不需要响应式，可以使用Object.freeze冻结属性\r\nfunction defineReactive(obj, key, value) { // 此处会产生闭包（闭包不会太耗费性能，也不会泄露），value会向上层的value查找\r\n  // 递归观测数据，不管有多少层我都要观测\r\n  // 如果数据是一个数组那么数组的每一项也会增加get和set，假如说数组的数据多会很耗费性能，所以说数组就不要进行 defineProperty(数组也支持defineProperty)\r\n  // vue3中为了兼容proxy内部对数组用的就是defineProperty\r\n  // 按照常理来说用户修改数组无非采用数组的方法，只要把能改变数组的数组的方法重写就可以了（push pop shift unshift reverse sort splice）\r\n  observe(value);\r\n  Object.defineProperty(obj, key, {\r\n    get() {\r\n      return value; // 此处不能用obj[key]去取值，\r\n    },\r\n    set(newValue) {\r\n      console.log('设置新值')\r\n      if(newValue === value) return;\r\n      // 继续观测新值，否则如果新值是对象或者数组的话就不是响应式的了\r\n      observe(newValue)\r\n      value = newValue\r\n    }\r\n  })\r\n}\r\nexport function observe(data) {\r\n  // console.log(data)\r\n  // 如果data不是对象，就不用观测了\r\n  // 此处如果是数组也会走到Observer,里面会判断是否是数组\r\n  if(!isObject(data)) {\r\n    return ;\r\n  };\r\n  // 如果一个对象被观测过了就会有这个__ob__,那么就不用再观测了\r\n  if(data.__ob__) {\r\n    return;\r\n  }\r\n  // 需要观测data,最外层必须是一个{}，不能是数组，\r\n  // 如果一个数据已经被观测过了，就不要再观测了，用类来实现，观测之后就增加一个标识，再观测是去检测，做出判断\r\n  return new Observer(data);\r\n}","import { observe } from \"./observe\";\r\nimport { isFunction } from \"./utils\";\r\n\r\nexport function initState(vm) {\r\n  const options = vm.$options;\r\n  if(options.data) { // 如果有data属性\r\n    initData(vm)\r\n  }\r\n};\r\n\r\nfunction proxy(vm, key, source) { // 此处也会有闭包\r\n  Object.defineProperty(vm, key, {\r\n    get() {\r\n      return vm[source][key];\r\n    },\r\n    set(newValue) {\r\n      vm[source][key] = newValue;\r\n    }\r\n  })\r\n};\r\n\r\nfunction initData(vm) {\r\n  console.log(vm);\r\n  // data是函数或者对象\r\n  let data = vm.$options.data;\r\n  // 只有根实例可以传一个对象，组件必须传函数  data和vm_data引用的是同一个空间，data被劫持了，vm._data也被劫持了\r\n  data = vm._data = isFunction(data) ? data.call(vm) : data;\r\n  /**\r\n   * 我们把数据挂载到vm上因为我们需要让用户通过vm.xxx 的方式拿到xxx数据，\r\n   * 此时我们思考通过vm.$options.data() 是否可以呢，当然不可以因为我们在执行一次拿到的数并不是响应式的数据\r\n   * 我们把_data放到vm上看起来不是用户写的\r\n   * 此时vm._data.xxx也不是我们想要的结果\r\n   * 想要达到我们想要的结果我们就接着用 Object.defineProperty + for in 的方式把data代理就可以了\r\n   */\r\n  // 需要将data变成响应式的，重写data中的所有属性\r\n  // console.log(data);\r\n  // console.log(observe)\r\n  observe(data);\r\n  // 把data代理到vue实例上，取值的时候再去做代理(懒代理，只有取值的时候才代理)，不是暴力的去赋值，（暴力的去赋值会有命名冲突问题）\r\n  for(let key in data) { //vm.xxx => vm._data.xxx\r\n    proxy(vm, key, '_data')\r\n  }\r\n  // console.log(data);\r\n  // data.list.push('23123');\r\n  // data.list.pop(1)\r\n}","import { compilerToFunction } from \"./compiler\";\r\nimport { initState } from \"./state\";\r\n\r\nexport function initMixin(Vue) {\r\n  Vue.prototype._init = function (options) {\r\n    // console.log(options)\r\n    // 初始化的流程\r\n    const vm = this;\r\n    // 把用户选项放到vm上,后续有其他的扩展的方法想要拿到用户选项就可以通过vm去拿，$：VUE内部的\r\n    vm.$options = options;\r\n    // 初始化状态\r\n    initState(vm);\r\n    // options中有el、data\r\n    if(vm.$options.el) {\r\n      // 走到这的时候，数据已经被劫持了,数据的变化需要更新视图， diff算法更新需要更新的部分\r\n      // 如果有el要将数据挂载到页面上\r\n      console.log('页面要挂载');\r\n      // ast语法树 将template编译成一个树结构 描述为一个树结构 将代码重组成js语法\r\n      // 模板编译原理 把template模板编译成render函数 render函数返回虚拟dom 然后生成真实dom 如果数据更新了再执行render 通过diff算法比对\r\n      // 挂载dom的地方有 el、$mount方法， 模板的方式直接写 render template 无论用哪种方式最终都是调用的一个方法: $mount\r\n      vm.$mount(vm.$options.el)\r\n    }\r\n  }\r\n  Vue.prototype.$mount = function(el) {\r\n    const vm = this;\r\n    // 获取真实的DOM\r\n    el = document.querySelector(el);\r\n    vm.$el = el\r\n    // 看看配置项里面有没有render函数，因为render函数的优先级最高，如果没有看看有没有template模板，如果template模板也没有就用el里面的内容\r\n    if(!vm.$options.render) {\r\n      let template = vm.$options.template;\r\n      if(!template) {\r\n        // outerHTML指的是当前元素的整个内容（包含这个元素），innerHTML指的是元素里面的东西（不包含当前元素）\r\n        template = el.outerHTML\r\n      };\r\n      let render = compilerToFunction(template);\r\n      vm.$options.render = render;\r\n    }\r\n\r\n    // console.log(vm.$options.render)\r\n  }\r\n};\r\n   \r\n// 1.new Vue 会调用_init方法进行初始化操作\r\n// 2.会将用户的选项放到 vm.$options上\r\n// 3.会对当前属性上搜素有没有data 数据   initState\r\n// 4.有data 判断data是不是一个函数 ，如果是函数取返回值 initData\r\n// 5.observe 去观测data中的数据 和 vm没关系，说明data已经变成了响应式\r\n// 6.vm上像取值也能取到data中的数据 vm._data = data 这样用户能取到data了  vm._data\r\n// 7.用户觉得有点麻烦 vm.xxx => vm._data\r\n// 8.如果更新对象不存在的属性，会导致视图不更新， 如果是数组更新索引和长度不会触发更新\r\n// 9.如果是替换成一个新对象，新对象会被进行劫持，如果是数组存放新内容 push unshift() 新增的内容也会被劫持\r\n// 通过__ob__ 进行标识这个对象被监控过  （在vue中被监控的对象身上都有一个__ob__ 这个属性）\r\n// 10如果你就想改索引 可以使用$set方法 内部就是splice()\r\n\r\n\r\n\r\n// vue技术点\r\n// 1.编译原理\r\n// 2.响应式原理 依赖收集\r\n// 3.组件化开发 （贯穿了vue的流程）\r\n// 4.diff算法\r\n\r\n\r\n// 如果有el 需要挂载到页面上\r\n","// vue的构造函数导出vue给别人使用, vue的实现方式：原型模式，所有的功能都通过原型扩展的方式来添加\r\n\r\nimport { initMixin } from \"./init\";\r\n\r\nfunction Vue(options) {\r\n  // 实现vue的初始化\r\n  this._init(options)\r\n}\r\n// 把Vue当作参数传进去\r\ninitMixin(Vue)\r\nexport default Vue;\r\n\r\n/**\r\n * 1.\r\n */"],"names":["ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parserHTML","html","stack","root","createAstElement","tag","attrs","parent","type","children","start","console","log","length","element","push","end","tagName","pop","text","chars","replace","advance","len","substring","parseStartTag","match","arr","name","value","index","indexOf","startTagMatch","endTagMatch","defaultTagRE","generate","ast","genChildren","code","genProps","undefined","str","i","attr","styles","arguments","JSON","stringify","join","map","item","gen","el","test","tokens","compilerToFunction","template","isFunction","data","isObject","isArray","Array","oldArrayProperty","prototype","arrayMethods","Object","create","methods","forEach","method","args","call","inserted","ob","__ob__","slice","observeArray","Observer","constructor","defineProperty","enumerable","__proto__","walk","observe","keys","key","defineReactive","obj","get","set","newValue","initState","vm","options","$options","initData","proxy","source","_data","initMixin","Vue","_init","$mount","document","querySelector","$el","render","outerHTML"],"mappings":"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"}